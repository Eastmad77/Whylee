// /scripts/entitlements.js  (v9007)// Provides entitlement helpers. Exports BOTH a modern named function `isPro`// and a legacy object `Entitlements` so existing imports continue to work.import {  auth,  db,  doc,  getDoc,  getIdTokenResult,} from "/scripts/firebase-bridge.js?v=9007";/** Resolve a UID whether caller passed a string or a User object */function uidOf(userOrUid) {  if (typeof userOrUid === "string") return userOrUid;  if (userOrUid && typeof userOrUid === "object" && userOrUid.uid) return userOrUid.uid;  return auth.currentUser?.uid || null;}/** Get current token claims (optionally force refresh) */export async function getClaims(forceRefresh = false) {  const user = auth.currentUser;  if (!user) return {};  const res = await getIdTokenResult(user, forceRefresh);  return res?.claims || {};}/** Force-refresh token claims (use after server-side change) */export async function refreshClaims() {  return getClaims(true);}/** * Primary check used by UI to gate Pro features. * We check, in order: * 1) Custom auth claims (e.g., stripeRole === 'pro' or activePlans contains 'pro') * 2) Firestore fallback: users/{uid}.pro === true OR users/{uid}.subscription.status === 'active' */export async function isPro(userOrUid) {  const uid = uidOf(userOrUid);  if (!uid) return false;  // 1) Claims (fast)  const claims = await getClaims(false);  if (claims?.stripeRole === "pro") return true;  if (Array.isArray(claims?.activePlans) && claims.activePlans.includes("pro")) return true;  if (claims?.pro === true) return true;  // 2) Firestore (fallback)  try {    const ref = doc(db, "users", uid);    const snap = await getDoc(ref);    if (snap.exists()) {      const u = snap.data() || {};      if (u.pro === true) return true;      if (u.subscription?.status === "active") return true;    }  } catch (e) {    console.warn("[entitlements] Firestore check failed:", e);  }  return false;}/** Legacy object used by some older modules */export const Entitlements = { isPro, getClaims, refreshClaims };export default Entitlements;